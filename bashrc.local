export EMAIL_ADDR=lakshmankumar@gmail.com
alias ls='ls --color -F'
alias grep='egrep --color'
alias gitnp='git --no-pager'
alias npgit='git --no-pager'
alias gittags='git for-each-ref --sort=creatordate --format "%(refname) ; %(creatordate)" refs/tags | column -t -s\; | cut -c11-'
alias gr='cd ./$(git rev-parse --show-cdup) ; export GITROOT=$(pwd)'
alias ttyrec='$HOME/software/ttyrec/ttyrec/ttyrec'
alias ttygif='$HOME/software/ttygif/ttygif'
alias ttygif_concat='$HOME/software/ttygif/concat.sh'
alias lsdir='find . -maxdepth 1 ! -path . -type d'
alias nonl='tr -d "\n"'
alias man='TERM=xterm man'
alias pwdtmux="pwd | tr -d '\n' | tmux loadb -"
alias tmuxcopy="tr -d '\n' | tmux loadb -"
alias tp="cd $HOME/tmp"

#bless my typo
alias snv=svn

alias svnstm="svn status | awk '/^M/ { print \$2 }'"
alias svnstx="svn status | awk '/^X/ { print \$2 }'"
alias svnstq="svn status | awk '/^\?/ { print \$2 }'"
alias svnstt="svn status | awk '/^\~/ { print \$2 }'"
alias svnstc="svn status | awk '/^C/ { print \$2 }'"
alias svnstd="svn status | awk '/^!/ { print \$2 }'"

#help nvim terminal exit
alias aexit="exit"

function check_array() {
    arrayname=$1[@] ;
    array=(${!arrayname}) ;
    printf "elem: %s\n" "${array[@]}" ;
}
alias array_print=check_array

col() {
    if [ -z "$1" ] ; then
        field=1
    else
        field="$1"
        shift
    fi
    awk "$@" '{print $'"${field}"' }'
}

back() {
    if [ -z "$1" ] ; then
        how_much=1
    else
        how_much=$1
    fi
    back=$(printf "../%.0s" {1..${how_much}})
    cd ${back}
    pwd
}

svnst() {
    svn status | awk ' BEGIN { m="" ; c = "" ; q = "" ; r="" ; allelse = "" ; prop_set }
        /^Performing/ { next }
        /^.[^[:space:]]/ { prop_set = prop_set "\n" $2 }
        /^M/  { m = m "\n" $2 ; next }
        /^C/  { c = c "\n" $2 ; next }
        /^\?/ { q = q "\n" $2 ; next }
        /^\~/ { r = r "\n" $2 ; next }
        /^\!/ { d = d "\n" $2 ; next }
        /^X/  { next }
        /^ /  { next }
        /^$/  { next }
        1    { allelse = allelse "\n" $2 }
        END  { if (length(m) != 0)       { printf "### MODIFIED:%s\n",m } ;
               if (length(c) != 0)       { printf "### CONFLICT:%s\n",c } ;
               if (length(q) != 0)       { printf "### UNTRACKED:%s\n",q } ;
               if (length(r) != 0)       { printf "### REPLACED:%s\n",r } ;
               if (length(d) != 0)       { printf "### DELETED:%s\n",d } ;
               if (length(prop_set) != 0){ printf "### PROPERTY SET(!):%s\n",prop_set } ;
               if (length(allelse) != 0) { printf "### ALL ELSE:%s\n",allelse } }'
}

alias psme="ps -u lakshman_narayanan -o pid,ppid,tt,%mem,rss,bsdstart,args --sort +rss"
killallthisterm() {
    kill -9 $(ps -o pid= | grep -v $$)
}
alias damnit=killallthisterm

pstreeme() {
    login_pids=($(psme | grep -- '-[b]ash' | awk '{print $1}') )
    for i in "${login_pids[@]}" ; do
        pstree -p $i
    done
}

# List the cwd of each login bash
pstreemewhere() {
    login_pids=($(psme | grep -- '-[b]ash' | awk '{print $1}') )
    for i in "${login_pids[@]}" ; do
        pstree -A -p $i
    done | awk -F- '
            /^bash/ {
                if (!length($4)) {
                    next
                }
                match($4,/.*\((.*)\)/,pid);
                system("ls -ld /proc/" pid[1] "/cwd")
            }';
}

export FORGE='lakshman_narayanan@mforge2:/home/lakshman_narayanan'
export GOPATH="$HOME/gopath"

hostspecific=""
hn=$(hostname)
case $hn in
    mforge2*)
    hostspecific=/home/lakshman_narayanan/gitlab/aryaka-scripts/m2_overrides
    ;;
    mforge3*)
    hostspecific=/home/lakshman_narayanan/gitlab/aryaka-scripts/m3_overrides
    ;;
    tforge.corp.aryaka.com*)
    hostspecific=/home/lakshman_narayanan/gitlab/aryaka-scripts/t1_overrides
    ;;
    lakshman-dev*)
    hostspecific=/home/lakshman_narayanan/gitlab/aryaka-scripts/dev_overrides
    ;;
esac

export PATH="$PATH:$HOME/.local/bin"

#regular order
export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin

host=$(hostname)
if [ "$host" = "mforge3.corp.aryaka.com" -o "$host" = "lakshman-dev" ] ; then
    export EDITOR=nvim
else
    export EDITOR=vim
fi
export GITHUB="git@github.com:lakshmankumar12"
export GITLAB="git@gitlab.com:lakshmankumar12"
export BITBUCKET="git@bitbucket.org:lakshmankumar12"

#export LESS="$LESS -R -F"

export NVIM_SWAP="$HOME/.local/share/nvim/swap"
alias lsnvimswap="ls $NVIM_SWAP"

prune_paths()
{
  export PATH=$(echo $PATH | tr ':' '\n'  | awk '!x[$0]++' | tr '\n' ':')
  export LD_LIBRARY_PATH=$(echo $LD_LIBRARY_PATH | tr ':' '\n'  | awk '!x[$0]++' | tr '\n' ':')
}
alias recfg='. ~/.zshrc ; prune_paths'

ovcs()
{
  # over-writes cscope
  mv tmpcsc cscope.out
  mv tmpcsc.in cscope.in.out
  mv tmpcsc.po cscope.po.out
}

newcsc()
{
  echo "Rebuilding cscope from cscope.files into tmpcsc"
  if [ ! -f cscope.files ] ; then
    echo "Huh .. There is no cscope.files"
    return 1
  fi
  if [ -f tmpcsc.out ] ; then
    echo "Huh .. There is already a tmpcsc.out here. Please clean that up first!"
    return 1
  fi
  echo "starting cscope in background"
  cscope -bqki cscope.files -f tmpcsc &
  cscope_pid=$!
  echo -n "Rebuilding ctags .. "
  ctags -L cscope.files --c++-kinds=+p --fields=+iaS --extra=+q
  egrep ';"[[:space:]]f' tags > tags_f
  egrep ';"[[:space:]]m' tags > tags_m
  egrep ';"[[:space:]](s|t)' tags > tags_s
  egrep ';"[[:space:]](d|e)' tags > tags_d
  echo "done"
  echo -n "waiting for cscope($cscope_pid) to complete .. "
  check_for_pid $cscope_pid
  ovcs
  echo "done"
}

check_for_pid()
{
  if [ -z "$1" ] ; then
    echo "supply pid"
    return
  fi

  pid=$1
  while [ 1 ] ; do
    kill -s 0 $pid 2> /dev/null
    if [ $? -eq 0 ] ; then
      sleep 2
    else
      break
    fi
  done
}

track_time_pid()
{
  if [ -z "$1" ] ; then
    echo "supply pid"
    return
  fi

  pid=$1
  echo "Time is now $(date)"
  ps -eo pid,lstart | grep $pid
  while [ 1 ] ; do
    kill -s 0 $pid 2> /dev/null
    if [ $? -eq 0 ] ; then
      sleep 2
    else
      date
      break
    fi
  done
}

function lsd()
{
   eval ls --color -F -d "*$1*"
}


analy()
{
    if [ ! -d /proc/$1 ] ; then 
        echo "process $1 has no proc/$1 dir"
        return
    fi
    cat /proc/$1/cmdline | tr '\0' '\n'
    ls -l /proc/$1/cwd
}

when_rebooted() {
    date -d@"$(( $(date '+%s') - $(printf "%.0f" $(awk '{print $1}' /proc/uptime)) ))"
}

howlong()
{
  ps -o pid=,etime= "$@"
}

howlongs()
{
  ps -o pid=,etimes= "$@"
}

sincewhen()
{
    date -d@$(( $(date '+%s') - $(ps -o etimes= "$1") ))
}

#you invoke it as:
# check_arg1 var_to_store  "$1" "You missed blah-blah";  if [ $? -ne 0 ] ; then return 1 ; fi ; shift
check_arg1() {
    var_name="$1"
    if [ -z "$2" ] ; then
        echo "$3"
        return 1
    fi
    eval ${var_name}="$2"
}

#you invoke it as:
# check_opt_arg1 var_to_store  "$1" ; if [ $? -ne 0 ] ; then shift ; fi
check_opt_arg1() {
    var_name="$1"
    if [ -z "$2" ] ; then
        eval ${var_name}=""
        return 1
    fi
    eval ${var_name}="$2"
}

pgrp()
{
    pids=$(pgrep -if "$1" | tr '\n' ',')
    shift
    if [ -n "$pids" ]; then
        if [ -n "$*" ] ; then
            ps "$@" -fp $pids
        else
            ps -fp $pids
        fi
    fi
}

study_args() {
    #Search: list arg args study count
    echo "No of args given: ${#[@]}"
    c=1
    for i in "$@" ; do
        echo "Arg $c: $i"
        c=$((c+1))
    done
}

function ft() {
    $HOME/github/vimfiles/open_first_tab.py "$@"
}
function ftp() {
    $HOME/github/vimfiles/open_first_tab.py -p "$@"
}
function ftn() {
    $HOME/github/vimfiles/open_first_tab.py -n "$@"
}
function ftc() {
    $HOME/github/vimfiles/open_first_tab.py -c "$@"
}
function ftnc() {
    $HOME/github/vimfiles/open_first_tab.py -N "$@"
}
function ftt() {
    $HOME/github/vimfiles/open_first_tab.py -t "$@"
}
function ftt1() {
    $HOME/github/vimfiles/open_first_tab.py -t 1
}
alias 1gt=ftt1
alias a1gt=ftt1
function ftt2() {
    $HOME/github/vimfiles/open_first_tab.py -t 2
}
alias 2gt=ftt2
alias a2gt=ftt2

remove_ssh_host() {
    sed -i -e '/'"$1"'/d' $HOME/.ssh/known_hosts
}
export SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes"

calc()
{
  bc <<< "scale=2; $@"
}

hextodec() {
    for i in "$@" ; do
        i=${i#0x}
        i=${i#0X}
        printf "0x${i} %d\n" "0x${i}"
    done
}
alias h2d=hextodec

dectohex() {
    for i in "$@" ; do
        printf "$i 0x%x\n" $i
    done
}
alias d2h=dectohex

catc ()
{
    if [ -z "$1" ]; then
        col_count=80
    else
        col_count=$1
        shift
    fi
    awk -v cols=$col_count '{printf "%.*s\n",cols,$0}' "$@"
}

vi()
{
  if [ -n "$NVIM_LISTEN_ADDRESS" ] ; then
    ftc "tabnew $1"
  else
    #$HOME/bin/vim -u $HOME/.vimrc "$@"
    nvim "$@"
  fi
}

alias vsh='vi -c "terminal" -c "startinsert"'

viewpdf()
{
  if [ -z "$1" ] ; then
    echo "Supply pdf file"
    return 1
  fi
  pdftotext -layout $1 - | vim -R -
}

do_on_success()
{
  if [ $? -ne 0 ] ; then
    echo "previous status was failure"
    return
  fi
  "$@"
}

open_conver()
{
  if [ -z "$1" ] ; then
    echo "Supply the html file"
    return 1
  fi
  if [ ! -f "$1" ] ; then
    echo "html file $1 doesn't seem to be present"
    return 1
  fi
  htmltotext.py $1 | vim -R -
}

function echo_color() {
    local in_color="$1"
    local msg="$2"
    local pat256=0
    case $in_color in
        black)
            use_color=30
            ;;
        red)
            use_color=31
            ;;
        green)
            use_color=32
            ;;
        yellow)
            use_color=33
            ;;
        blue)
            use_color=34
            ;;
        magenta)
            use_color=35
            ;;
        cyan)
            use_color=36
            ;;
        white)
            use_color=37
            ;;
        color[0-9]*)
            use_color=${in_color##color}
            if [ $use_color -lt 0 ] || [ $use_color -gt 256 ] ; then
                echo "color value out of range (0-256): $in_color"
                return
            fi
            pat256=1
            ;;
        * )
            echo "Unknown color"
            return
            ;;
    esac
    if [[ $pat256 -eq 1 ]] ; then
        color_msg='\033[38;5;'"${use_color}"'m'
    else
        color_msg='\033[0;'"${use_color}"'m'
    fi
    echo -e "${color_msg}${msg}"'\033[0;0m'
}

function yellow_sep() {
    echo_color yellow "=================="
}

function echo_lines() {
    for i in "$@" ; do
        echo $i
    done
}

#all tmux stuff
listtmuxpanes()
{
  if [ -z "$1" ] ; then
    session=$(tmux display-message -p '#S')
  else
    session="$1"
  fi
  if [ -f /tmp/tmuxbuffer/pane_id ] ; then
    current_pane=$(cat /tmp/tmuxbuffer/pane_id)
  else
    current_pane="unavailable"
  fi
  tmux set-env -g TMUX_TEMP_CURR_PANE "${current_pane}"
  tmux list-panes -s -t $session -F "#S|#I|#W|#P|#T|#{window_id}|#{pane_id}|#{pane_tty}|#{?#{==:#{TMUX_TEMP_CURR_PANE},#{pane_id}},current,}"
}

listalltmuxpanes()
{
    for i in $(tmux list-sessions -F '#S') ; do
        listtmuxpanes $i
    done
}

listalltmuxpanesptysorted()
{
    listalltmuxpanes | sort -t\| -k 8
}

listalltmuxpids()
{
    awk '
        NR==FNR  {
            key="/dev/" $3 ;
            exist ="" ;
            if (key in psttydict) {
                exist = psttydict[key] "\n"
            } ;
            exist = exist "               " substr($0,1,120) ;
            psttydict[key]=exist;
            next
        }
        FNR == 1 {
            print "Unassociated to TTY" ;
            print psttydict["/dev/?"]
        }
        1 {
            print $0 ;
            if ($8 in psttydict) {
                print psttydict[$8]
            }
        }
    ' <(psme) <(listalltmuxpanes | tr '|' ' ')
}

psmewithtmuxpanes() {
    awk '
        NR==FNR {
            value=$1 "." $3 ":" substr($5,1,15) ;
            value=substr(value,1,30) ;
            ttydict[$8]=value ;
            next
        } 1 {
            key="/dev/" $3 ;
            if (key in ttydict) {
                tty=ttydict[key]
            } else {
                tty=$3
            } ;
            $3=tty;
            printf "%6s %6s %30s %6s %8s %10s ",$1,$2,$3,$4,$5,$6 ;
            s="" ;
            for ( i = 7 ; i <= NF ; ++i) s = s " " $i ;
            print s
        }
    '  <(listalltmuxpanes | tr '|' ' ' ) <(psme)
}
alias mc=psmewithtmuxpanes

# prints an output if some tmux pane is logging
listtmuxlogpanes()
{
   ps -ef | grep '\<cat\>' | grep -v grep
   pids=$(ps -ef | grep '\<cat\>' | grep -v grep | awk '{print $2}')
   for i in $pids ; do
     echo "$i"
     lsof -p $i
   done
}
alias ltl=listtmuxlogpanes
alias ltf="cd $HOME/tmuxlogs ; ls"

dumptmuxclip() {
    tmux save-buffer /tmp/tmuxclip
    cat /tmp/tmuxclip
}

dumptmuxpane()
{
    if [ -z "$1" -o "$1" = "-h" -o "$1" = "--help" ] ; then
        echo "Supply absolute pane id. Include the percent% sign"
        echo "Usage: dumptmuxpane <absolute-pane-id> [<filename>]"
        return
    fi
    if [ -z "$2" ] ; then
       file="$(pwd)/log.txt"
    else
        if [ "${2:0:1}" == "/" ] ; then
            file="$2"
        else
            file="$(pwd)/$2"
        fi
    fi
    target_pane=$1
    grep '^%[[:digit:]]+$' <(echo ${target_pane}) > /dev/null
    if [[ $? -ne 0 ]] ;  then
        echo "Supply a valid-paneid of the form %num. Got: ${target_pane}"
        return 1
    fi
    tmux capture-pane -eCJ -S- -t "${target_pane}"
    tmux save-buffer $file
}

putpaneid() {
    # Just head the 3 lines off tmux-clip. If there is 10K junk in there
    # we dont want to waste counting all. Just need to know if there is a
    # valid pane-id there.
    nolines=$(tmux saveb - | head -n3 | wc -l)
    if [[ $nolines != 0 ]] ; then
        echo "%-1"
        return 1
    fi
    tmuxclip=$(tmux saveb -)
    grep '^%[[:digit:]]+$' <(echo ${tmuxclip}) > /dev/null
    if [[ $? -ne 0 ]] ;  then
        echo "%-1"
        return 1
    fi
    echo ${tmuxclip}
}
alias ppi=putpaneid

getAllLogFromPane()
{
    if [ -z "$2" ] ; then
       file=$(pwd)/log
    else
       file=$(pwd)/$2
    fi
    dumptmuxpane $1 ${file}
    if [ $? -ne 0 ] ; then
        return 1
    fi
    sed -i -r -e 's/[[:space:]]+$//' -e 's:\\033\[[0-9;]*[mK]::g' -e 's:\x1B\[[0-9;]*[mK]::g' ${file}
    vi $file
}
alias galogp='getAllLogFromPane $(ppi)'
galogpn() {
    getAllLogFromPane $(ppi) $1
}

getLogFromPane()
{
    pane=$1
    shift
    if [ -z "$1" ] ; then
       file=$(pwd)/log
    else
       file=$(pwd)/$1
       shift
    fi
    openvi="yes"
    strip=""
    while [ 1 ] ; do
        if [ -z "$1" ] ; then
            break;
        fi
        if [ "$1" = "skip" ] ; then
            echo "skipping vi"
            openvi=""
            shift
            continue
        fi
        if [ "$1" = "strip" ] ; then
            echo "will strip color chars"
            strip="yes"
            shift
            continue
        fi
        echo "Unrecognized arg: $1, Usage: getLogFromPane <pane-id> [<file-name>] [skip] [strip]"
        return 1
    done
    dumptmuxpane $pane ${file}
    if [ $? -ne 0 ] ; then
        return 1
    fi
    number=$(grep -n HERE $file | tail -n 1 | cut -d: -f1); number=$(expr $number - 1) ; echo $number
    sed -i -e "1,${number}d" -e 's/[[:space:]]\+$//' $file
    if [ -n "$strip" ] ; then
        sed -r 's:\\033\[[0-9;]*[mK]::g' -i $file
        sed -r 's:\x1B\[[0-9;]*[mK]::g' -i $file
    fi
    if [ -n "$openvi" ] ; then
        vi $file
    fi
}
alias glogp='getLogFromPane $(ppi) log strip'
glogpn() {
    getLogFromPane $(ppi) $1 strip
}

tmuxatt()
{
  if [ -z "$1" ] ; then
    session="main"
  else
    session="$1"
  fi
  if [ -f /usr/share/terminfo/s/screen-256color-bce ] ; then
    export TERM=screen-256color-bce
  elif [ -f /usr/share/terminfo/s/xterm-256color ] ; then
    export TERM=xterm-256color
  else
    echo "No screen-256color-bce or xterm-256color in /usr/share/terminfo/s. Not setting TERM. current TERM is $TERM"
  fi
  tmux -2 -u attach -d -t $session
  if [ $? -ne 0 ] ; then
      echo "Got a failure code.. list all sessions"
      tmux list-session
  fi
}
alias ta='tmuxatt 02-'
alias tav='tmuxatt virt'

tmux_win_title_get()
{
  #tmux list-panes -s -F "#W|#{pane_id}" | grep --color=none "$TMUX_PANE" | cut -d\| -f 1
  echo $(tmux display-message -p '#W')
}

tmux_pane_title_get()
{
  #tmux list-panes -s -F "#T|#{pane_id}" | grep --color=none "$TMUX_PANE" | cut -d\| -f 1
  echo $(tmux display-message -p '#T')
}

tmux_info_pane() {
    eval $(tmux display-message -p 'sn="#S"; wn="#W"; pn="#T"; pidx="#P"; pid=#{pane_id}')
    echo "Session-Name(sn): ${sn}"
    echo "Window-name(wn) : ${wn}"
    echo "Pane-name(pn)   : ${pn}"
    echo "Pane-index(pidx): ${pidx}"
    echo "Pane-id(pid)    : ${pid}"
}

tmux_pane_title_set() {
  if [ -z "$1" ]; then
    echo "supply title"
    return
  fi
  #printf '\033]2;%s\033\\' $1
  tmux select-pane -T "$1"
}

tmux_win_title_set() {
  if [ -z "$1" ]; then
    echo "supply title"
    return
  fi
  printf '\033k%s\033\\' $1
}

tmux_set_fg_color() {
  if [ -z "$1" ]; then
    echo "supply a number from 0(default) to 2"
    return
  fi
  value="default"
  if [ $1 -eq "1" ]; then
    value="fg=colour48"
  elif [ $1 -eq "2" ]; then
    value="fg=colour200"
  fi
  tmux select-pane -P $value
}

tcrt() {
    win_name=""
    sess_name="$(tmux display-message -p '#S')"
    dir="$HOME"
    detach="no"
    command=""
    while [[ $# > 0 ]] ; do
        key="$1"
        shift 1
        case $key in
            -n|--name)
                win_name="-n "'"'"$1"'"'
                shift
                ;;
            -s|--sess)
                sess_name="$1"
                shift
                ;;
            -d|--dir)
                dir="$1"
                shift
                ;;
            -D|--detach)
                detach="yes"
                ;;
            -C|--command)
                command="$1"
                shift
                ;;
            *)
                echo "tcrt [-n|--name window_name] [-s|--sess session_name] [-d|--dir dir] [-C|--command <command>] [-D|--detach]"
                return 1
                ;;
        esac
    done
    if [ "$detach" = "yes" ] ; then
        detach_arg="-d"
    else
        detach_arg=""
    fi
    cmd="pane_id=\$(tmux new-window -t "'"'"${sess_name}:"'"'" ${win_name} -c "'"'"${dir}"'"'" ${detach_arg} -P -F "'"'"#{pane_id}"'"'")"
    echo "${cmd}"
    eval "${cmd}"
    if [ -n "${command}" ] ; then
        tmux send-keys -t ${pane_id} "${command}" "C-m"
    fi
}

gotoTmuxPane() {
    target_session="$1"
    target_window="$2"
    target_pane="$3"

    current_pane=$(tmux display-message -p '#I:#P')
    current_window=$(tmux display-message -p '#I')
    current_session=$(tmux display-message -p '#S')
    if [[ $current_session != $target_session ]]; then
      tmux switch-client -t $target_session
    fi

    tmux select-window -t "${target_session}:${target_window}.${target_pane}"
    tmux select-pane -t "${target_session}:${target_window}.${target_pane}"
}

gotoNotes() {
    gotoTmuxPane 01-main 0 0
}

gotoGenxNotes() {
    gotoTmuxPane 01-main 1 0
}

gotoCurrentCode() {
    gotoTmuxPane 02-code 0 0
}

gotoDotFiles() {
    gotoTmuxPane 01-main 2 0
}

gotoLaunchPad() {
    gotoTmuxPane 03-test 1 0
}

gotoCurrentExecution() {
    gotoTmuxPane 03-test 2 0
}

gotoCurrentExecutionSecond() {
    gotoTmuxPane 04-svt 20 0
}

getSessionWindowPaneForPaneId() {
    if [ -z "$1" ] ; then
        pane_id=$(tmux display-message -p '#{pane_id}')
    else
        pane_id="$1"
    fi
    pane_line=$(listalltmuxpanes | grep -w $pane_id)
    if [ $(echo ${pane_line} | wc -l) != 1 ] ; then
        return
    fi
    session_name=$(echo $pane_line | cut -d\| -f 1)
    window_id=$(echo $pane_line | cut -d\| -f 2)
    pane_id=$(echo $pane_line | cut -d\| -f 4)
    echo "$session_name $window_id $pane_id"
}

gotoAbsolutePaneId() {
    sessWindPane=$(getSessionWindowPaneForPaneId $1)
    if [[ -z "${sessWindPane// }" ]] ; then
        echo "No pane found for $1"
        return
    fi
    sessWindPandArr=()
    for i in $sessWindPane ; do
        sessWindPandArr+=($i)
    done
    gotoTmuxPane ${sessWindPandArr[0]} ${sessWindPandArr[1]} ${sessWindPandArr[2]}
}

gotoWindowGivenbyFile() {
    file=$1
    if [ -f ${file} ] ; then
        gotoAbsolutePaneId $(cat ${file})
    fi
}

gotoWindowGivenbyW() {
    gotoWindowGivenbyFile $HOME/tmuxlogs/.windowForW
}

gotoWindowGivenbyG() {
    gotoWindowGivenbyFile $HOME/tmuxlogs/.windowForG
}

gotoWindowGivenbyX() {
    gotoWindowGivenbyFile $HOME/tmuxlogs/.windowForX
}
gotoWindowGivenbyR() {
    gotoWindowGivenbyFile $HOME/tmuxlogs/.windowForR
}
gotoWindowGivenbyP() {
    gotoWindowGivenbyFile $HOME/tmuxlogs/.windowForP
}

settmuxWindowForG() {
    echo "$1" > $HOME/tmuxlogs/.windowForG
}
settmuxWindowForW() {
    echo "$1" > $HOME/tmuxlogs/.windowForW
}
settmuxWindowForX() {
    echo "$1" > $HOME/tmuxlogs/.windowForX
}
settmuxWindowForR() {
    echo "$1" > $HOME/tmuxlogs/.windowForR
}
settmuxWindowForP() {
    echo "$1" > $HOME/tmuxlogs/.windowForP
}

fzfchoosepane() {
    pane_id=$(listalltmuxpanes | column -t -s '|' | fzf --exact --prompt 'switch session: ' --reverse | cut -d\% -f2 | awk '{print $1}')
    if [ -z "${pane_id}" ] ; then
        return
    fi
    gotoAbsolutePaneId "%${pane_id}"
}

cmdsh()
{
  GREPPER_CMD=/home/lakshman/gitlab/genxcomm-notes/grepper_commands
  mkdir -p /tmp/tmuxbuffer
  FILE=/tmp/tmuxbuffer/resultcmdsh
  DIR_PREFIX=$(dirname $FILE)
  rm -f /tmp/tmuxbuffer/resultcmdsh
  cat $GREPPER_CMD | fzf --exact --reverse --no-sort -m > $FILE
}

cmdsh2ndpart()
{
  FILE=/tmp/tmuxbuffer/resultcmdsh
  DIR_PREFIX=$(dirname $FILE)
  if [ -f $FILE ] ; then
    :
  else
    #/usr/bin/inotifywait $DIR_PREFIX -e create -e moved_to | while read path action file; do : ; done
    sleep 2
  fi
  if [ -s $FILE ] ; then
    :
  else
    echo " " > $FILE
  fi
  perl -pi -e 's/^;#.*?;#\s*//;s/\s*;#.*$//;chomp if eof' $FILE
}

cmdshnew() {
    cmdsh
    cmdsh2ndpart
    tmux load-buffer /tmp/tmuxbuffer/resultcmdsh
    gotoAbsolutePaneId $(cat /tmp/tmuxbuffer/pane_id)
    tmux send-keys "C-u"
    tmux paste-buffer
}

savecurrentpane() {
    pane_id=$(tmux display-message -p '#{pane_id}')
    echo -n ${pane_id} > /tmp/tmuxbuffer/pane_id
}

tmuxsendhereanddate () {
  date=$(date)
  tmux send-keys "C-m" "C-m" "  #HERE:  $date" "C-m" "C-m"
}

#cd to the contents in tmux clipboard
cdtmuxclip () {
  tmuxclip=$(tmux saveb -)
  if [ -d $tmuxclip ] ; then
    cd $tmuxclip
  else
    echo "tmux clip doesn't seem to be a valid dir. Set a valid dir and cdtmuxclip again"
  fi
}

tmuxserv() {
    ps -ef | grep tmux | grep '\?' | awk '{print $2}'
}

shoottmuxpanes() {
    me=$(tmux display-message -p '#{pane_id}')
    tmux list-panes -s  -F '#{pane_id}' | grep -v ${me} | while read i ; do tmux kill-pane -t $i ; done
    tmux move-window -t 0 2> /dev/null
}

shootallvims() {
    awk '   NR==FNR {
                ttydict[$8]=$7 ;
                next
            } 1 {
                key="/dev/" $3 ;
                if (key in ttydict) {
                    command=sprintf("tmux send-keys -t \"%s\" Escape \"::qa\" C-m\n",ttydict[key]) ; system(command)
                }
            } '  FS='|' <(listalltmuxpanes) FS=' ' <(psme | grep '[n]vim' )
}

# From https://gist.github.com/msabramo/746585#file-pyval-sh
_pyval() {
    local python_cmd="print $@"
    python -c "${python_cmd}"

    case "$shopts" in
        *noglob*) ;;
        *) set +f;;
    esac

    unset shopts
}
alias pyval='shopts="$SHELLOPTS"; set -f; _pyval'

#mp3 stuff
makemp3()
{
   if [ -z "$1" -o -z "$2" ] ; then
      echo "makemp3 <whatever> <target>"
      return 1
   fi
   avconv -i "$1" -vn -acodec libmp3lame "$2".mp3
}

rejigcovermp3()
{
  \ls *.mp3 | tr '\n' '\0' | xargs -0 -n 1 eyeD3 --remove-all-images
  \ls *.mp3 | tr '\n' '\0' | xargs -0 -n 1 eyeD3 -2 --add-image 'cover.jpg:FRONT_COVER'
}

extractcovermp3()
{
  if [ -z "$1" ] ; then
    echo "supply mp3"
    return
  fi
  coverdir="cover-$1"
  mkdir -p "$coverdir"
  if [ $? -ne 0 ] ; then
    echo "problem creating dir"
    return
  fi
  eyeD3 "--write-images=$coverdir" "$1"
}

loaddisplay()
{
   echo $DISPLAY > /tmp/last_display
   DISP_FILE=~/.displayset
   if [ -f $DISP_FILE ] ; then
     perl -pi -e 'chomp if eof' $DISP_FILE
     export DISPLAY=$(cat $DISP_FILE)
   fi
}
loaddisplay

removecolorandctrlm()
{
    if [ ! -f $1 ] ; then
      echo "Supply a file name"
      return
    fi
    sed -i -r -e 's:\x1B\[[0-9;]*[mK]::g' -e 's:\x0d::g' $1
}

resetclipvm()
{
  op=$(ps -ef | grep VBoxClient | grep clip)
  lines=$(echo $op | wc -l)
  if [ $lines -ne 1 ] ; then
    echo "Got more than one line - $op"
    return 1
  fi
  pid=$(echo $op | awk '{print $2}')
  echo "killing pid: $pid, op:$op"
  kill -9 $pid
  echo "starting again"
  /usr/bin/VBoxClient --clipboard
}

fdfile()
{
    local file=$(fzf)
    if [ -n "$file" ] ; then
        dir=$(dirname $file)
        if [ -d "$dir"  ] ; then
            cd $dir
            echo "$file"
            ls $(basename $file)
        fi
    fi
}

fd()
{
  local dir
  # ./ is default, other find from $1
  # path "*/\.*" -prune will filter out hidden dirs
  # -o
  dir=$(find -L ${1:-.} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf --no-sort +m --exact) &&
  cd "$dir"
}

fdg()
{
  a=./$(git root)
  if [ $? -ne 0 ] ; then
    echo "Trouble with git root"
    return
  fi
  b=$(cd $a; pwd)
  fd $b
}

lspwd()
{
  \ls -1 "$@" | awk -v pwd="$(pwd)" ' { print pwd "/" $0 }'
}

macnotify()
{
  if [ -z "$1" ] ; then
    echo "Supply message!"
    return
  fi
  message=$1
  if [ -z "$2" ] ; then
    title "No Title Given"
  else
    title=$2
  fi
  osascript -e 'display notification "'"$message"'" with title "'"$title"'"'
}

unprotect_pdf_owner_pass()
{
    ownerpass=$1
    lockedpdf=$2
    unlockedpdf=$3
    if [ -z "$ownerpass" -o -z "$lockedpdf" -o -z "$unlockedpdf" ]; then
        echo "Usage unprotect_pdf_owner_pass <owner-pass> <lockedpdf> <unlockedpdf>"
    fi
    pdftk $lockedpdf input_pw $ownerpass cat output $unlockedpdf
}

unprotect_pdf_user_pass()
{
    userpass=$1
    lockedpdf=$2
    unlockedpdf=$3
    if [ -z "$userpass" -o -z "$lockedpdf" -o -z "$unlockedpdf" ]; then
        echo "Usage unprotect_pdf_user_pass <user-pass> <lockedpdf> <unlockedpdf>"
    fi
    qpdf --password=$userpass --decrypt $lockedpdf $unlockedpdf
}

ifaddr()
{
  ip addr show | awk ' /^[0-9]+:/ { ifname=$2  } /^[  ]+inet / { print ifname " " $2  } ' | grep "$1"
}

myip()
{
  ip route get $(ip route show | grep default | grep -Po 'via \K[^[:space:]]+') | grep -Po 'src \K[^[:space:]]+'
}

ilshow()
{
    ip link show | awk ' /^[0-9]+:/ { id=$1; link=$2; getline; print id " " link " " $0  } ' | grep "$1"
}

get_rate_if()
{
    if [ -n "$1" ] ; then
        intf=$1
    else
        intf="eth0"
    fi
    while [ 1  ] ; do
        ifconfig $intf | grep 'RX bytes' ;
        sleep 1;
    done  | awk 'BEGIN { sec = -1; start_sec = 1}{
                sec += 1;

                rx_bytes=$2 ; gsub(/bytes:/,"",rx_bytes);
                tx_bytes=$6 ; gsub(/bytes:/,"",tx_bytes);

                rx_1s_diff= (rx_bytes - rx_bytes_prev); rx_bytes_prev = rx_bytes;
                tx_1s_diff= (tx_bytes - tx_bytes_prev); tx_bytes_prev = tx_bytes;

                if (sec == 0) {
                    next;
                }

                rx_val_arr[sec] = rx_1s_diff;
                tx_val_arr[sec] = tx_1s_diff;
                if (sec > 15) {
                    del rx_val_arr[start_sec];
                    del tx_val_arr[start_sec];
                    start_sec += 1;
                }

                rx_5s_diff = 0; tx_5s_diff = 0; rx_15s_diff = 0; tx_15s_diff = 0; j=1;
                for (i=sec; i >= start_sec; i--) {
                    if (j<=5) {
                        rx_5s_diff += rx_val_arr[i];
                        tx_5s_diff += tx_val_arr[i];
                    }
                    rx_15s_diff += rx_val_arr[i];
                    tx_15s_diff += tx_val_arr[i];
                    j++;
                }

                rx_diff_rate = (rx_1s_diff * 8) / (1000000) ;
                tx_diff_rate = (tx_1s_diff * 8) / (1000000) ;
                rx_5s_rate = (rx_5s_diff * 8) / (5*1000000);
                tx_5s_rate = (tx_5s_diff * 8) / (5*1000000);
                rx_15s_rate = (rx_15s_diff * 8) / (15*1000000);
                tx_15s_rate = (tx_15s_diff * 8) / (15*1000000);
                cmd="date"
                cmd | getline time
                close (cmd)
                printf "%s(%d): rx: %d rx_rate: \033[0;36m%.3f/\033[0;33m%.3f/\033[0;32m%.3f\033[0;0m Mbps tx: %d tx_rate: \033[0;36m%.3f/\033[0;33m%.3f/\033[0;32m%.3f\033[0;0m Mbps\n", time, sec, \
                             rx_bytes, rx_diff_rate, rx_5s_rate, rx_15s_rate, \
                             tx_bytes, tx_diff_rate, tx_5s_rate, tx_15s_rate }'
}



startdevdocInMac() {
    #docker run -p 51413:51413 -p 5143:51413/udp -p 9091:9091 -P --rm --name devbox --hostname DevBox --privileged -e DISPLAY=$DISPLAY -u lakshman -v /dev:/dev -v  /tmp/.X11-unix:/tmp/.X11-unix:ro -v $HOME:/var/shared -v /Volumes:/mnt -v $HOME/.Xauthority:/home/lakshman/.Xauthority -v $(echo $DISPLAY  | awk -F: '{print $1}' | xargs dirname):$(echo $DISPLAY  | awk -F: '{print $1}' | xargs dirname) -t -i lakshmankumar/my-dev-bo
    #VOLUMES="-v /dev:/dev -v $HOME:/var/shared -v /Volumes:/mnt -v $HOME/.Xauthority:/home/lakshman/.Xauthority -v $(echo $DISPLAY  | awk -F: '{print $1}' | xargs dirname):$(echo $DISPLAY  | awk -F: '{print $1}' | xargs dirname) "
    VOLUMES="-v /dev:/hostdev -v $HOME:/var/shared -v /Volumes:/mnt "
    docker run -P -p 51413:51413 -p 51413:51413/udp --rm --name devbox --hostname DevBox --privileged $VOLUMES -u lakshman -t -i lakshmankumar/my-dev-box
}

startvpndocInMac() {
    VOLUMES="-v $HOME:/var/shared "
    docker run -P --rm --name for-vpn --hostname ForVpn --privileged $VOLUMES -u lakshman -t -i lakshmankumar/my-dev-box
}

startdeldocInMac() {
    VOLUMES="-v $HOME:/var/shared "
    docker run -P --rm --name todel --hostname ToDel --privileged $VOLUMES -u lakshman -t -i lakshmankumar/my-dev-box
}

sshvpndoc() {
  port=$(docker port for-vpn | grep '22/tcp' | grep -o ':.*$' | tr -d :)
  echo "Port is $port"
  ssh -Y -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $port lakshman@localhost
}

sshdevdoc() {
  port=$(docker port devbox | grep '22/tcp' | grep -o ':.*$' | tr -d :)
  echo "Port is $port"
  ssh -Y -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $port lakshman@localhost
}

sshdevdocargs() {
  port=$(docker port devbox | grep '22/tcp' | grep -o ':.*$' | tr -d :)
  ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $port lakshman@localhost "$@"
}

sshdeldoc() {
  port=$(docker port todel | grep '22/tcp' | grep -o ':.*$' | tr -d :)
  echo "Port is $port"
  ssh -Y -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $port lakshman@localhost
}

sshmachine() {
  mc="$1"
  ssh -Y -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@${mc}
}

listlogins() {
    ps -ef | grep '[s]shd' | grep -v root
}

setup_prompt_msg() {
    found=""
    for i in "${POWERLEVEL9K_LEFT_PROMPT_ELEMENTS[@]}" ; do
        if [ "$i" == "prompt_msg" ] ; then
            found="yes"
            break
        fi
    done
    if [ "$found" == "yes" ] ; then
        echo "prompt_msg is already in POWERLEVEL9K_LEFT_PROMPT_ELEMENTS. PR_MSG is ${PR_MSG}"
        return
    fi
    POWERLEVEL9K_LEFT_PROMPT_ELEMENTS+=(prompt_msg)
    if [ -n "$1" ] ; then
        export PR_MSG="$1"
    else
        echo "Ensure to have PR_MSG set. Its now : ${PR_MSG}"
    fi
}

prompt_prompt_msg() {
    echo -n "${PR_MSG}"
}

showpath() {
    echo $PATH | tr ':' '\n'
}

unalias alert 2> /dev/null
alert() {
    if [ -z "$1" ] ; then
        echo "Supply message"
        return
    fi
    echo -n "$*" | nc -4 -w1 $(cat ~/.mymacip) 25020
}

to_mac_clip() {
    toSet=$(cat)
    l=$(echo "$toSet" | wc -l)
    echo -n "$toSet" | sed 's/\x1b\[[0-9;]*m//g' | ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $(cat $HOME/.mymacport) $(cat $HOME/.mymacusername)@$(cat $HOME/.mymacip) pbcopy
    if [[ $? -ne 0 ]] ; then
        echo_color red "Trouble in ssh'ing back mac"
        return 1
    fi
    if [[ $l -le 3 ]] ; then
        echo "Your clip is setup with: $toSet"
    else
        echo "Your clip is setup with $l lines"
    fi
}

check_clip() {
    sudo lsof -Pn -i4TCP:25020
    use_color=33 #yellow
    color_msg='\033[38;5;'"${use_color}"'m'
    reset_msg='\033[0;0m'
    echo -e "## check_clip at ${color_msg}$(date)${reset_msg}" | to_host_clip
    echo "You can check your clip by pasting"
}
alias ccc=check_clip

clip_username() {
    user="lakshman.narayanan"
    if [ "$1" == "vpn" ] ; then
        user="lakshman"
    fi
    echo "setting to $user"
    echo "$user" > $HOME/.mymacusername
}

from_mac_clip() {
    ssh -p $(cat /home/lakshman_narayanan/.mymacport) lakshman.narayanan@$(cat /home/lakshman_narayanan/.mymacip) pbpaste
}

to_winhost_clip() {
    file=/host_c/Users/laksh/Documents/cliptest.txt
    cat > $file
    #strip newline from last-line
    printf %s "$(< $file)" > $file
}

to_host_clip_huge() {
    cat > /tmp/cliptest.txt ; scp /tmp/cliptest.txt laptop:/host_c/Users/laksh/Documents/cliptest.txt
}

to_host_clip() {
    if [ "$(hostname)x" == "lakshmandevhetznerx" ] ; then
        cat | nc localhost 25020
    else
        to_winhost_clip "$@"
    fi
}
export to_host_clip
alias hhc=to_host_clip

tmuxcliptohost() {
    tmux show-buffer | to_host_clip
}
alias thc=tmuxcliptohost

totmuxclip() {
    cat | tmux loadb -
}
alias ttc=totmuxclip

alert_on_pid() {
    if [ -z "$1" -o -z "$2" ] ; then
        echo "Supply pid, message"
        return
    fi
    check_for_pid $1
    shift
    alert "$*"
}

ping_check() {
    if [ -z "$1" ] ; then
        echo "Provide machine/ip to ping"
        return
    fi
    while [ 1 ] ; do
        ping -c 1 $1
        if [ $? -eq 0 ]; then
            break;
        fi
    done
}

ssh_host_clear() {
    if [ -z "$1" ] ; then
        echo "Supply the line number"
        return
    fi
    echo "Erasing line $1 from ~/.ssh/known_hosts"
    sed -i -e "${1}d" ~/.ssh/known_hosts
}

shows() {
    column -s\` -t listened_songs | tail -n 30
}

wapp() {
    song_info=$(wap)
    title=$(echo "$song_info" | grep 'Title:' | cut -c15-)
    artist=$(echo "$song_info" | grep 'Artist:' | cut -c15-)
    album=$(echo "$song_info" | grep 'Album:' | cut -c15-)
    artUrl=$(echo "$song_info" | grep 'ArtUrl:' | cut -c15-)
}

getlyrp() {
    if [ -z "$1" ] ; then
        song_info=$(wap)
    else
        if [ "x$1" = "xsp" ] ; then
            song_info=$(wasp)
        else
            echo "Unknown $1 .. nothing or sp"
            return
        fi
    fi
    title=$(echo "$song_info" | grep 'Title:' | cut -c10-)
    artist=$(echo "$song_info" | grep 'Artist:' | cut -c10-)
    getlyr "$title" "$artist"
}

collect() {
    song_info=$(wap)
    echo "$song_info" | collect_song_detail_to_db.py "$@"
}

fzf2dirs()
{
    fzfndirs "${@}"
}

fzfndirs()
{
    unset s
    unset d
    ainternal=$(find "${@}" -type f | fzf --exact)
    if [ -z "$ainternal" ] ; then
        return 1
    fi
    export s="$ainternal"
    export d=`dirname "$s"`
}

cdd()
{
    if [ -z "$d" ] ; then
        echo "d is not set"
        return
    fi
    cd "$d"
}

extract_sng_info() {
    name="$1"
    name=$(basename "$name")
    name=${name%.*}
    export title=$(echo $name | awk -F- '{gsub(/^ +/,"",$1); print $1}')
    export artist=$(echo $name | awk -F- '{gsub(/^ +/,"",$2); print $2}')
    export album=$(echo $name | awk -F- '{gsub(/^ +/,"",$3); print $3}')
    echo -e "title:$title\nartist:$artist\nalbum:$album"
}

isknownsong() {
    if [ -z "$1" ] ; then
        echo "supply grep material"
        return
    fi
    grep -i -n "$1" current_list pandoraScrobble.txt scrob-Track/* Lookout.txt
}

isknownsaavn() {
    if [ -z "$1" ] ; then
        echo "supply grep material"
        return
    fi
    (cd /Users/lakshman.narayanan/Downloads/songs-download/JUST-PLAYLISTS-TEXT/saavnscrobbles ;
        grep -i -E "\b$*\b" $(cat Categories.txt | tr '\n' ' ') )
}
alias saavnIsKnown=isknownsaavn

evalVariablePresence()
{
    # Usage: evalVariablePresence YOUR_VAR_TO_CHECK [verbose]
    toCheck=$1
    shift
    if [ -n "$1" -a "$1" = "verbose" ] ; then
        debug="yes"
        shift
    else
        debug="no"
    fi
    if [ -n "${(P)toCheck}" ] ; then
        if [ "x$debug" = "xyes" ] ; then
            echo "${toCheck} is set to ${(P)toCheck}"
        fi
        return 0
    fi
    echo "${toCheck} is unset"
    return 1
}

if [ -f ~/.bashrc.aryaka.centos.sh ] ; then
  . ~/.bashrc.aryaka.centos.sh
fi

if [ "$(uname)x" == "Darwinx" ] ; then
  . ~/.bashrc.darwin
fi

if [ "$(hostname)x" == "DevBoxx" ] ; then
  . ~/.bashrc.devbox
fi

if [ "$(hostname)x" == "lakshman-VirtualBoxx" ] ; then
  . ~/.bashrc.virtualbox
fi

if [ -f ~/.bashrc.private.sh ] ; then
  . ~/.bashrc.private.sh
fi

delink () { tmpfile="$1$(date)"; cp -a "$1" "$tmpfile"; mv "$tmpfile" "$1"; }

pcol() {
    awk -v col=$1 ' { print $col }'
}

errecho() {
    2>&1 echo "$@"
}

scptomforge3() {
    if [ -z "$1" -o "$1" == "-h" -o "$1" == "--help" ] ; then
        echo "scptomforge3 <tgt-dir-in-mforge3> <one-or-more-files-to-scp>"
        return
    fi
    dir="$1"; shift
    if [ -z "$1" ] ; then
        echo "missing file. Use -h for help"
        return
    fi
    scp "$@" lakshman_narayanan@mforge3.corp.aryaka.com:${dir}
}

scp_with_anap_key_from() {
    if [ -z "$1" -o "$1" == "-h" -o "$1" == "--help" ] ; then
        echo "scp_with_anap_key_from <anap> <full-path-in-anap> [<save-name>]"
        return
    fi
    anap="$1"; shift
    if [ -z "$1" ] ; then
        echo "missing file. Use -h for help"
        return
    fi
    file=$1
    shift
    if [ -n "$1" ]; then
        save_name="$1"
    else
        save_name="$(pwd)/"
    fi
    scp -i ~/.ssh/anap_shared_key root@${anap}:${file} ${save_name}
}
scp_with_aryaka_user_key_from() {
    if [ -z "$1" -o "$1" == "-h" -o "$1" == "--help" ] ; then
        echo "scp_with_anap_key_from <anap> <full-path-in-anap>"
        return
    fi
    anap="$1"; shift
    if [ -z "$1" ] ; then
        echo "missing file. Use -h for help"
        return
    fi
    file=$1
    scp -i ~/.ssh/anap_aryaka_key aryaka@${anap}:${file} .
}

lsfile() {
    file=$1
    while read i ; do
        ls "$i"
    done < ${file}
}

mypublicip() {
    dig @resolver1.opendns.com -4 myip.opendns.com +short
}

screenht() {
    seq 100 -1 1
}
screenwd() {
    if [ -n "$1" ] ; then
        times=$1
    else
        times=20
    fi
    printf "1234567890%.0s" $(seq 1 $times)
}

killothermosh() {
    myMosh=$(ps -ef | grep '[m]osh-server' | grep $PPID)
    if [ -z "$myMosh" ]; then
        echo "please run this directly in a mosh'ed shell"
        return 1
    fi
    otherMosh=$(ps -ef | grep '[m]osh-server' | grep -v $PPID)
    if [ -z "$otherMosh" ] ; then
        echo "No other mosh detected"
        return 1
    fi
    pidsToKill=$(echo "${otherMosh}" | awk '{print $2}')
    echo "Killing ${pidsToKill}"
    kill -9 ${pidsToKill}
}

rmgorig() {
    list=$(git newfiles | grep '.orig')
    if [ -z "$list" ] ; then
        echo "No orig files"
    else
        eval rm $list
    fi
}

rmgrej() {
    for i in $(git newfiles | grep '.rej') ; do
        echo $i ;
        echo -n "clear(y/n)?" ; read yn ;
        if [ $yn = "y" ] ; then
            rm $i
        fi
    done
}

flip_comments() {
    file=$1 ; shift
    start=$1 ; shift
    if [ -n "$1" ] ; then
        no_lines=$1
        shift
    else
        no_lines=1
    fi
    for line in $(seq $start $(($start+$no_lines-1))) ; do
        echo "working on line ${line} in file ${file}"
        is_commented=$(sed -n "${line}p" ${file} | grep '<!--')
        if [ -n "$is_commented" ] ; then
            echo "Uncommenting"
            sed -i -e "${line}"'s/^\([[:space:]]*\)<!--/\1/' -e "$line"'s/-->\([[:space:]]*\)$/\1/' $file
        else
            echo "Commenting"
            sed -i -e "$line"'s/^\([[:space:]]*\)</\1<!--</' -e "$line"'s/>\([[:space:]]*\)$/>-->\1/' $file
        fi
        echo -n "line ${line} is now:"
        sed -n "${line}p" ${file}
    done
}

rmfdir() {
    echo "$1" | sed 's|^[^/]*/||'
}

gototag() {
    force="no"
    tag="unset"
    while [ -n "$1" ] ; do
        key="$1"
        if [ "$key" = "-f" ] ; then
            force="yes"
            shift
        elif [ "$key" = "-t" ] ; then
            if [ -z "$2" ] ; then
                echo "You didn't supply tag"
                return 1
            fi
            tag="$2"
            shift 2
        else
            echo "Unknown arg: $key"
            return 1
        fi
    done
    if [ "$tag" = "unset" ] ; then
        echo "Supply -t <tag>"
        return 1
    fi
    modified=$(git lsm)
    newfiles=$(git newfiles)
    if [ "$force" != "yes" ] ; then
        if [ -n "$modified" ] ; then
            echo "You have modified files: $modified"
            return 1
        fi
        if [ -n "$newfiles" ] ; then
            echo "You have untracked files: $newfiles"
            return 1
        fi
    fi
    git reset --hard $tag
    git logol
}
gobase() {
    gototag -t base "$@"
}
gowt() {
    gototag -t working_tip "$@"
}
rebaseup() {
    git rebase update
}
taga() {
    git resetatag lakshman_a "$1"
}
tagb() {
    git resetatag lakshman_b "$1"
}
tagab() {
    if [ -z "$2" ] ; then
        echo "usage: tagab <commitA> <commitB>"
        return 1
    fi
    taga "$1" > /dev/null
    tagb "$2" > /dev/null
    git logol lakshman_b
}

getcssh() {
    ssh -G "$1" | grep -w --color=never \
        -e "user" \
        -e "hostname" \
        -e "port" \
        -e "exitonforwardfailure" \
        -e "passwordauthentication" \
        -e "pubkeyauthentication" \
        -e "identityfile" \
        -e "proxycommand"
}

ep_to_time() {
    if [ -z "$1" ] ; then
        echo "supply epoch"
        return 1
    fi
    date '-d@'"$1"
}

ep_to_time_utc() {
    TZ=UTC ep_to_time "$@"
}

ep_to_time_ist() {
    TZ=Asia/Kolkata ep_to_time "$@"
}

ep_to_time_cent() {
    TZ=America/Chicago ep_to_time "$@"
}

now() {
    date
}

declare -A time_zones
time_zones["ist"]="Asia/Kolkata"
time_zones["cent"]="America/Chicago"
time_zones["utc"]="Etc/UTC"
alias now_utc="TZ=${time_zones[utc]} now"
alias now_ist="TZ=${time_zones[ist]} now"
alias now_cent="TZ=${time_zones[cent]} now"

get_tz_zone() {
    if [ -z "$1" ] ; then
        echo "Time-zone missing"
        return 1
    fi
    if [ -z "${time_zones[$1]}" ] ; then
        echo "Unknown time-zone:$1"
        return 1
    fi
    echo "${time_zones[$1]}"
}

convert_src_zone_to_dst_zone() {
    src_zone=$(get_tz_zone "$1")
    if [ $? -ne 0 ] ; then echo "src-tz: $src_zone" ; return 1 ; fi
    shift
    dst_zone=$(get_tz_zone "$1")
    if [ $? -ne 0 ] ; then echo "dst-tz: $dst_zone" ; return 1 ; fi
    shift
    if [ -z "$1" ] ; then
        echo "supply hour in 24 format"
        return 1
    fi
    asked_hr="$1" ; shift
    if [ "$asked_hr" -le 0 -o "$asked_hr" -ge 24 ] ; then
        echo "Bad asked_hr:$asked_hr"
        return 1
    fi
    now_ep=$(date '+%s')
    now_date=$(TZ="Etc/UTC" date "-d@$now_ep" "+%Y-%m-%d")
    ask_date="${now_date}T${asked_hr}:00:00"
    ask_ep=$(TZ="$src_zone" date -d"$ask_date" "+%s")
    TZ="$dst_zone" date -d"@$ask_ep"
}

now_ep() {
    date '+%s'
}

converttz() {
    python $HOME/github/quick-utility-scripts/convert_time_from_zones.py
}
alias ctz=converttz

get_gitlab_diff_url() {
    check_arg1 left_commit  "$1" "Supply left commit";  if [ $? -ne 0 ] ; then return 1 ; fi ; shift
    check_arg1 right_commit "$1" "Supply right commit"; if [ $? -ne 0 ] ; then return 1 ; fi ; shift
    check_opt_arg1 file_blob "$1" ; if [ $? -ne 0 ] ; then shift ; fi
    url="https://gitlab.com/gxc_corenw/onyx-corenw/-/compare/${left_commit}...${right_commit}"
    if [ -n "$file_blob" ] ; then
        url="${url}#${file_blob}"
    fi
    echo "$url"
}

## source: https://superuser.com/a/117600
latest_file_in_directory () {
    dir=${1:-.}
    name=${2:-*}
    find "$(cd ${dir} ; pwd)" -maxdepth 1 -type f -name "$name" -printf '%T@.%p\0' | \
            sort -znr -t. -k1,2 | \
            while IFS= read -r -d '' -r record ; do
                    printf '%s' "$record" | cut -d. -f3-
                    break
            done
}
latest_dir_in_directory () {
    find "${@:-.}" -mindepth 1 -maxdepth 1 -type d -printf '%T@.%p\0' | \
            sort -znr -t. -k1,2 | \
            while IFS= read -r -d '' -r record ; do
                    printf '%s' "$record" | cut -d. -f3-
                    break
            done
}

cleanup_tails() {
    file="$1"
    was_int="$2"
    if [ -f $file ] ; then
        while read pid ; do
            echo "killing pid: $pid"
            kill -9 $pid
        done < ${file}
        rm $file
    fi
    echo "Done with cleanup"
    if [ -n "$was_int" ] ; then
        continue_tailing="no"
    fi
}

tail_latest() {
    filters="$1"
    latest_file=""
    tmpfile=$(mktemp /tmp/tail-pids-XXXXXXX)
    trap "cleanup_tails $tmpfile yes" INT
    continue_tailing="yes"
    while [ "$continue_tailing" == "yes" ] ; do
        new_file=$(eval latest_file_in_directory $filters)
        if [ "$new_file" != "$latest_file" ]; then
            cleanup_tails $tmpfile
            latest_file="$new_file"
            tail -n 0 -F "$latest_file" &
            tail_pid=$!
            echo "Tailing $latest_file with pid: $tail_pid"
            echo $tail_pid >> $tmpfile
        fi
        sleep 1
    done
}
link_latest() {
    dir=$(latest_dir_in_directory)
    if [ -n "$dir" ] ; then
        rm -f latest
        ln -s $dir latest
    fi
}

npdumpcrt() {
    openssl x509 -in $1 -noout -text
}
dumpcrt() {
    npdumpcrt $@ | less
}
npdumpcrtin() {
    openssl x509 -noout -text
}
dumpcrtin() {
    openssl x509 -noout -text | less
}

if [ -f /home/linuxbrew/.linuxbrew/bin/brew ] ; then
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi

#rev-order
export PATH=$HOME/bin:$PATH
if [ -n "$hostspecific" ]; then
export PATH=$hostspecific:$PATH
fi

if [ -f ~/.bashrc.devhetzner.sh ] ; then
    . ~/.bashrc.devhetzner.sh
fi

login_container() {
    if [ -z "$1" ] ; then
        echo "Supply container name"
        return 1
    fi
    docker exec -it "$1" /bin/bash
}

re_confirm() {
    random=$(openssl rand -base64 4)
    read -p "Type this random string ${random}: " input
    if [ "x$random" != "x$input" ] ; then
        echo "Whatever you typed:$input mismatched .. get sober and try again"
        return 1
    fi
    return 0
}

delete_lakshman_vms() {
    vms=($(virsh list --all | awk '/lakshman/ {print $2}'))
    if [ -z "$vms" ] ; then
        echo "no vms found"
        return 1
    fi
    echo "Vms are: ${vms[@]}"
    re_confirm
    if [ $? -ne 0 ] ; then
        return
    fi
    for i in ${vms[@]} ; do
        echo "vm is $i"
        virsh destroy $i
        virsh undefine --remove-all-storage $i
    done
}

get_ipv4_on_ifc() {
    guest=$1
    ifc=$2
    if [ -z "$ifc" ] ; then
        echo "get_ipv4_on_ifc vm ifc"
        return
    fi
    virsh domifaddr --source agent $guest | awk -v ifc=$ifc '
        $1 ~ ifc {
            a = 1
        }
        a == 1 {
            if ($3 ~ /ipv4/) {
                print $4
            } ;
            if  ($1 != "-" ) {
                exit
            }
        } '
}

interactive_sleep() {
    value=$1
    if [ $value -le 0 ] ; then
        echo "Supply value to sleep"
        return
    fi
    count=$value
    echo "Sleeping $count secs"
    while [ $count -gt 0 ] ; do
        printf "\rsecs left: %4d" "$count"
        sleep 1
        count=$((count - 1))
    done
    echo
}

har_dump() {
    if [ ! -f "$infile" ] ; then
        echo "infile: $infile is not available"
        return
    fi
    jq '.log.entries | to_entries | .[] | "\(.key): \(.value.request.method) \(.value.request.url | if length > 200 then "..." + .[(length-200):] else . end)" ' $infile
}

har_dump_notrunc() {
    jq '.log.entries | to_entries | .[] | "\(.key): \(.value.request.method) \(.value.request.url)" ' $infile
}

har_show() {
    field="$1"
    jq '.log.entries['"$idx"'].'"$field"' | del(.headers)' $infile
}

har_show_as_json() {
    field1=$1 ; shift
    if [ -z "$1" ] ; then
        echo "You have to supply the field to show as json"
        return
    fi
    field2="$1"
    if [[ ! "$field2" == "."* ]] ; then
        field2=".$field2"
    fi
    har_show $field1 | jq $field2 | jq -r '.' | jq '.'
}

har_req_show() {
    har_show request
}

har_resp_show() {
    har_show response
}

har_req_show_field_as_json() {
    har_show_as_json request "$@"
}

har_resp_show_field_as_json() {
    har_show_as_json response "$@"
}

har_resp_show_dump_metrics() {
    har_show_as_json response content.text | jq -r '.' | jq -r '.data.data.result[0].values[] | "\(.[0]): \(.[1])" ' | awk -F: '{cmd="date -d@" $1; cmd | getline d; close(cmd); printf "%s: %s: %s\n",$1,d,$2}'
}

showconfigssh() {
    ssh -G "$1" | grep -i -w -e proxycommand -e user -e hostname -e identityfile -e port
}
